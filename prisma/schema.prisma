/**
 * @file prisma/schema.prisma
 * @description Schéma Prisma pour rabb.com.
 *   Modèles : User, Session, Account, Verification (gérés par better-auth)
 *   + ConnectedPlatform, Post, NotificationPrefs, Signature (métier rabb)
 *
 *   Nouveau modèle simplifié (post-refonte /compose) :
 *   - Post.platform (String singulier) — 1 post = 1 plateforme
 *   - AgentSession et PostPlatformContent supprimés
 *
 *   Prisma 7 : les URLs de connexion sont définies dans prisma.config.ts (migrations)
 *   et dans lib/prisma.ts via @prisma/adapter-pg (runtime).
 *
 *   Voir prisma.config.ts pour la configuration des migrations.
 */

generator client {
  provider = "prisma-client-js"
}

datasource db {
  // Prisma 7 : provider seul suffit ici — l'URL est passée via prisma.config.ts (CLI)
  // et via l'adapter PrismaPg({ connectionString }) dans PrismaClient (runtime).
  provider = "postgresql"
}

// ─── Modèles better-auth (ne pas renommer les champs — requis par l'adaptateur) ──

/**
 * Utilisateur de l'application.
 * Géré principalement par better-auth (signUp, signIn, etc.).
 * Les champs métier sont ajoutés ici (ex: avatarUrl).
 */
model User {
  id              String    @id @default(cuid())
  email           String    @unique
  name            String?
  avatarUrl       String?
  description     String?   // Bio/description publique du profil (max 500 chars)
  emailVerified   Boolean   @default(false)
  image           String?   // Champ requis par better-auth OAuth (photo de profil Google)
  // ID du workspace Late (profil conteneur qui regroupe les comptes sociaux connectés).
  // Créé automatiquement lors du premier clic "Connecter" sur /settings.
  lateWorkspaceId String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  sessions      Session[]
  accounts      Account[]
  posts         Post[]
  platforms     ConnectedPlatform[]
  notifPrefs    NotificationPrefs?
  signatures    Signature[]
  media         Media[]

  @@map("users")
}

/**
 * Session utilisateur.
 * Créée par better-auth lors du login, supprimée lors du logout.
 */
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

/**
 * Compte OAuth lié à un utilisateur.
 * Ex: compte Google, futur compte GitHub, etc.
 * Un utilisateur peut avoir plusieurs comptes OAuth.
 */
model Account {
  id                   String    @id @default(cuid())
  userId               String
  // better-auth v1 : `accountId` (ID chez le provider) + `providerId` (nom du provider)
  accountId            String    // Ex: ID Google de l'utilisateur, ou userId pour "credential"
  providerId           String    // "google", "credential", etc.
  accessToken          String?
  refreshToken         String?
  idToken              String?
  accessTokenExpiresAt DateTime?
  refreshTokenExpiresAt DateTime?
  scope                String?
  password             String?   // Hash du mot de passe (providerId "credential")
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("accounts")
}

/**
 * Tokens de vérification (email, reset password, etc.).
 * Créés par better-auth, supprimés après utilisation.
 */
model Verification {
  id         String   @id @default(cuid())
  identifier String   // email ou userId
  value      String   // Token haché
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verifications")
}

// ─── Modèles métier rabb ──────────────────────────────────────────────────────

/**
 * Réseau social connecté par l'utilisateur via getlate.dev.
 * Un utilisateur peut connecter plusieurs plateformes.
 * Chaque plateforme a un profil distinct dans getlate.dev.
 */
model ConnectedPlatform {
  id            String   @id @default(cuid())
  userId        String
  platform      String   // "instagram" | "tiktok" | "youtube" | "facebook"
  lateProfileId String   // ID du profil dans l'API getlate.dev
  accountName   String   // Nom affiché ex: "@mon_handle"
  avatarUrl     String?  // Photo de profil de la plateforme
  isActive      Boolean  @default(true)
  connectedAt   DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  posts Post[]

  // Un utilisateur ne peut avoir qu'un profil getlate.dev par plateforme
  @@unique([userId, platform, lateProfileId])
  @@index([userId])
  @@map("connected_platforms")
}

/**
 * Post de contenu (texte + médias) destiné à être publié sur UNE seule plateforme.
 *
 * Nouveau modèle simplifié : 1 post = 1 plateforme.
 * L'agent crée N posts (un par plateforme) lors de la génération.
 * Chaque post a son propre texte adapté et ses propres médias.
 *
 * Cycle de vie : DRAFT → SCHEDULED → PUBLISHED (ou FAILED)
 */
model Post {
  id            String     @id @default(cuid())
  userId        String
  text          String     // Contenu textuel adapté à la plateforme (max 63 206 chars)
  mediaUrls     String[]   @default([])   // URLs Supabase Storage
  platform      String     // Ex: "tiktok" — une seule plateforme par post
  status        PostStatus @default(DRAFT)
  scheduledFor  DateTime?  // Null si brouillon, défini si planifié
  publishedAt   DateTime?  // Rempli par Inngest après publication réussie
  latePostId      String?    // ID retourné par getlate.dev après publication
  platformPostUrl String?    // URL directe du post sur la plateforme sociale (ex: tiktok.com/...)
  failureReason   String?    // Message d'erreur si status = FAILED

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  connectedPlatform   ConnectedPlatform? @relation(fields: [connectedPlatformId], references: [id])
  connectedPlatformId String?

  // Index composés pour les requêtes fréquentes (liste par user+status, planning par date)
  @@index([userId, status])
  @@index([scheduledFor])
  @@map("posts")
}

/**
 * Statuts possibles d'un post.
 * DRAFT     : brouillon non planifié
 * SCHEDULED : planifié, en attente de publication par Inngest
 * PUBLISHED : publié avec succès via getlate.dev
 * FAILED    : échec de publication (voir failureReason)
 */
enum PostStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  FAILED
}

/**
 * Signature textuelle réutilisable pour un post.
 * Chaque signature est liée à UNE seule plateforme (1 post = 1 plateforme).
 * Plusieurs signatures par plateforme sont possibles, dont une marquée "par défaut".
 *
 * Cas d'usage : hashtags récurrents, CTA, liens bio, mentions légales.
 * La signature "par défaut" (isDefault = true) apparaît en premier dans le picker
 * du PostComposer et est suggérée lors de la composition.
 *
 * Règle d'unicité du défaut : un seul isDefault par (userId, platform).
 * Géré par la Server Action `setDefaultSignature` via transaction Prisma.
 */
model Signature {
  id        String   @id @default(cuid())
  userId    String
  name      String                // Libellé court : "Hashtags courts", "CTA pro", etc.
  text      String                // Contenu inséré dans le post (max 500 chars)
  platform  String                // "instagram" | "linkedin" | etc. (1 plateforme par signature)
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Index standard : toutes les signatures d'un user
  @@index([userId])
  // Index composé pour la requête fréquente : signatures d'un user + plateforme
  @@index([userId, platform])
  @@map("signatures")
}

/**
 * Média (image ou vidéo) uploadé par l'utilisateur dans sa galerie personnelle.
 * Stocké dans Supabase Storage (bucket `post-media`, chemin `{userId}/gallery/…`).
 * Un média peut être réutilisé dans plusieurs posts via MediaPicker.
 *
 * Cycle de vie :
 *  1. Upload client → presigned URL `/api/gallery/upload-url`
 *  2. PUT vers Supabase Storage
 *  3. saveMedia() Server Action → entrée créée ici
 *  4. deleteMedia() → supprime Storage + cette entrée
 */
model Media {
  id        String   @id @default(cuid())
  userId    String
  url       String                // URL publique Supabase Storage (permanente)
  filename  String                // Nom affiché dans la galerie
  mimeType  String                // "image/jpeg", "video/mp4", etc.
  size      Int                   // Taille en octets
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Index standard : tous les médias d'un user
  @@index([userId])
  // Index composé pour la pagination triée par date (requête principale de la galerie)
  @@index([userId, createdAt])
  @@map("media")
}

/**
 * Préférences de notifications de l'utilisateur.
 * Relation 1-1 avec User, créée lors de l'inscription.
 */
model NotificationPrefs {
  id               String  @id @default(cuid())
  userId           String  @unique
  emailOnFailure   Boolean @default(true)  // Email si publication échoue
  emailWeeklyRecap Boolean @default(true)  // Récapitulatif hebdomadaire

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_prefs")
}
